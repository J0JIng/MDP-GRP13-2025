from typing import Optional
from config.load_config import load_stm32_config
from link.base import Link
from stm.robot_controller import RobotController
import math
import time



class STMLink(Link):
    """Class for communicating with STM32 microcontroller over UART serial connection.

    ### RPi to STM32
    RPi sends the following commands to the STM32.

    #### Path mode commands
        High speed forward/backward, with turning radius of `3x1`. The algorithm server emits the
        following formats:
        - `FWnn`: Move forward in 10-step increments; `nn` ∈ {10, 20, ..., 90}
        - `BWnn`: Move backward in 10-step increments; `nn` ∈ {10, 20, ..., 90}
        - `FL00`: 90° forward-left turn
        - `FR00`: 90° forward-right turn
        - `BL00`: 90° backward-left turn
        - `BR00`: 90° backward-right turn

        Notes:
        - Only the `..00` turn variants are generated by the current algorithm. Variants like `FR30`
            are not used.
        - The algorithm may include non-STM motor commands such as `SNAP{id}_{L|C|R}` (camera trigger)
            and `FIN` (end of sequence) in its command list. These should be ignored by STM motion control
            or filtered out by the RPi command coordinator before sending to STM.

    #### Manual mode commands
    - `FW--`: Move forward indefinitely
    - `BW--`: Move backward indefinitely
    - `TL--`: Steer left indefinitely (approx. 90° forward turn)
    - `TR--`: Steer right indefinitely (approx. 90° forward turn)
    - `FSnn`: Crawl/slow forward movement by `nn` cm (indefinite with `--`)
    - `BSnn`: Crawl/slow backward movement by `nn` cm (indefinite with `--`)
    - `STOP`: Stop all servos
    - `RS00`: Reset sensors/gyro (software acknowledgement only)

    ### STM32 to RPi
    After every command, an acknowledgement should be provided to gate the next command.
    In this implementation, STMLink delegates motion to RobotController and synthesizes an
    acknowledgement based on the controller call result:
    - On success, `recv()` returns `"ACK"` once
    - On failure, `recv()` returns `"NACK"` once
    - If no prior `send()` call or already consumed, `recv()` returns `None`

    """

    def __init__(self):
        """
        Constructor for STMLink.
        """
        super().__init__()
        self.logger.debug("Initializing STMLink")
        self.config = load_stm32_config()
        self.robot: Optional[RobotController] = None
        self._last_ack: Optional[bool] = None
        self._ack_queue = None
        self.cur_offset = 0

    def set_ack_queue(self, ack_queue) -> None:
        """Bind a multiprocessing-aware queue to publish acknowledgement results."""
        self._ack_queue = ack_queue

    def connect(self):
        """Initialise RobotController using configured serial port and baud rate."""
        self.logger.info("Connecting to STM32 via RobotController")
        try:
            port = self.config["serial_port"]["id"]
            baud = self.config["serial_port"]["baud_rate"]
            self.robot = RobotController(port, baud)
            self.logger.info("RobotController initialised (port=%s baud=%s)", port, baud)
        except Exception as e:
            self.logger.error("Failed to initialise RobotController: %s")
            raise

    def disconnect(self):
        """Disconnect RobotController (release reference)."""
        self.logger.info("Disconnecting from STM32 (RobotController)")
        if self.robot is not None:
            # RobotController has no explicit close; rely on GC / driver cleanup
            self.robot = None
            self.logger.info("RobotController reference cleared")
        else:
            self.logger.warning("RobotController was not initialised")

    def send(self, message: str) -> None:
        """Translate high-level commands into RobotController calls.

        Supported tokens (case-insensitive):
        - FW-- / BW--: move indefinitely (maps to distance=999)
        - FWnn / BWnn: move by nn cm (nn is numeric, e.g. 10, 20, ...)
        - FR00 / FL00 / BR00 / BL00: 90-degree turns; forward/back determined by prefix
        - STOP / HALT: immediate halt
        - SNAP... / FIN: ignored here (handled by other subsystems)

        Args:
            message (str): single command token to execute
        """
        token = (message or "").strip().upper()
        if not token:
            self.logger.warning("Empty command token; ignoring")
            return

        # Ignore non-motion tokens commonly present in algorithm output
        if token.startswith("SNAP") or token == "FIN":
            self.logger.debug("Ignoring non-motion token: %s", token)
            return

        def _parse_distance(segment: str) -> Optional[int]:
            if segment == "--":
                return 999  # Indefinite distance sentinel understood by RobotController
            if segment.isdigit():
                return int(segment)
            return None

        def _parse_angle(segment: str) -> Optional[int]:
            if segment == "--":
                return 90  # Treat indefinite turn as a standard 90° sweep
            if segment.isdigit():
                return int(segment)
            return None

        def _ensure_robot() -> Optional[RobotController]:
            if self.robot is None:
                try:
                    port = self.config["serial_port"]["id"]
                    baud = self.config["serial_port"]["baud_rate"]
                    self.logger.info("Initialising RobotController (port=%s baud=%s)", port, baud)
                    self.robot = RobotController(port, baud)
                except Exception as exc:
                    self.logger.error("Failed to initialise RobotController: %s", exc)
                    return None
            return self.robot

        success = False
        performed_action = False

        try:
            # Halt commands
            if token in {"STOP", "HALT"}:
                robot = _ensure_robot()
                success = bool(robot and robot.halt())
                performed_action = robot is not None

            # Indefinite linear motion
            elif token == "FW--":
                robot = _ensure_robot()
                success = bool(robot and robot.move_forward(999))
                performed_action = robot is not None
            elif token == "BW--":
                robot = _ensure_robot()
                success = bool(robot and robot.move_backward(999))
                performed_action = robot is not None

            # Fixed-format 90-degree turns
            elif token in {"FR00", "FL00", "BR00", "BL00"}:
                robot = _ensure_robot()
                if robot is not None:
                    #  get yaw
                    prev_yaw = robot.get_yaw()
                    isFwd = None 

                    if token == "FR00":
                        success = bool(robot.turn_right(90, True))
                        isFwd = True 
                        self.cur_offset -= 90
                        if self.cur_offset < -180:
                            self.cur_offset %= 180

                    elif token == "FL00":
                        success = bool(robot.turn_left(90, True))
                        isFwd = True
                        self.cur_offset += 90
                        if self.cur_offset > 180:
                            self.cur_offset = -180 + (self.cur_offset % 180)

                    elif token == "BR00":
                        success = bool(robot.turn_right(90, False))
                        isFwd = False
                        self.cur_offset -= 90
                        if self.cur_offset < -180:
                            self.cur_offset %= 180
                    
                    elif token == "BL00":
                        success = bool(robot.turn_left(90, False))
                        isFwd = False
                        self.cur_offset += 90
                        if self.cur_offset > 180:
                            self.cur_offset = -180 + (self.cur_offset % 180)
                    
                    #  get yaw
                    cur_yaw = robot.get_yaw()
                    # run compensation algo
                    new_offset, dir = self.turn_error_minimization(prev_yaw, True, cur_yaw, self.cur_offset)
                    if (dir) :
                        if (isFwd):
                            robot.turn_left(int(new_offset), True)     
                        else:
                            robot.turn_left(int(new_offset), False) 

                    else:
                        if (isFwd):
                            robot.turn_right(int(new_offset), True)     
                        else:
                            robot.turn_right(int(new_offset), False) 
                        
                    
                    performed_action = True


            # Linear movement with numeric distance: FWnn / BWnn
            elif token.startswith("FW") and token[2:].isdigit():
                dist = int(token[2:])
                robot = _ensure_robot()
                # success = bool(robot and robot.move_forward(dist))
                success = bool(robot and robot.crawl_forward(dist))
                performed_action = robot is not None
            elif token.startswith("BW") and token[2:].isdigit():
                dist = int(token[2:])
                robot = _ensure_robot()
                # success = bool(robot and robot.move_backward(dist))
                success = bool(robot and robot.crawl_backward(dist))
                performed_action = robot is not None

            # Crawl/slow movement: FSnn / BSnn
            elif token.startswith("FS"):
                dist = _parse_distance(token[2:])
                if dist is None:
                    self.logger.error("Invalid FS token format: %s", token)
                    success = True  # Prevent deadlock; caller will continue
                else:
                    robot = _ensure_robot()
                    success = bool(robot and robot.crawl_forward(dist))
                    performed_action = robot is not None
            elif token.startswith("BS"):
                dist = _parse_distance(token[2:])
                if dist is None:
                    self.logger.error("Invalid BS token format: %s", token)
                    success = True
                else:
                    robot = _ensure_robot()
                    success = bool(robot and robot.crawl_backward(dist))
                    performed_action = robot is not None

            elif token == "OB01":
                robot = _ensure_robot()
                success = bool(robot and robot.crawl_forward_until_obstacle())
                performed_action = robot is not None

            # Manual steering: TLxx / TRxx (xx degrees, '--' treated as standard 90°)
            elif token.startswith("TL"):
                angle = _parse_angle(token[2:])
                if angle is None:
                    self.logger.error("Invalid TL token format: %s", token)
                    success = True
                else:
                    robot = _ensure_robot()
                    success = bool(robot and robot.turn_left(angle, True, no_brakes=(token[2:] == "--")))
                    performed_action = robot is not None
            elif token.startswith("TR"):
                angle = _parse_angle(token[2:])
                if angle is None:
                    self.logger.error("Invalid TR token format: %s", token)
                    success = True
                else:
                    robot = _ensure_robot()
                    success = bool(robot and robot.turn_right(angle, True, no_brakes=(token[2:] == "--")))
                    performed_action = robot is not None

            # Gyro reset acknowledgement – handled on STM32 side, but we propagate ACK.
            elif token == "RS00":
                success = True
                self.logger.info("Acknowledging RS00 command (handled on STM32 firmware).")

            # Reserve misc maintenance tokens with soft success to keep queue flowing
            elif token.startswith(("A", "C", "DT", "ZZ")):
                self.logger.warning(
                    "Received maintenance token %s with no local handler; acknowledging to keep pipeline moving.",
                    token)
                success = True

            else:
                self.logger.warning("Unrecognized motion token: %s", token)
                success = True

            if performed_action:
                if success:
                    self.logger.info("Executed robot motion: %s", token)
                else:
                    self.logger.warning("Robot rejected or failed to execute: %s", token)
            else:
                if success:
                    self.logger.debug("No-op token acknowledged without hardware action: %s", token)
                else:
                    self.logger.warning("Token %s did not trigger hardware action and was not acknowledged.", token)
        except Exception as e:
            self.logger.error("Error executing token %s: %s", token, e)
        finally:
            self._last_ack = success
            if self._ack_queue is not None:
                try:
                    self._ack_queue.put(success)
                except Exception as exc:
                    self.logger.debug("Failed to enqueue ack result: %s", exc)

    def recv(self) -> Optional[str]:
        """Return last command acknowledgement as 'ACK' or 'NACK'.

        Returns:
            Optional[str]: 'ACK' if last send succeeded, 'NACK' if it failed, None if unknown.
        """
        if self._last_ack is None:
            # self.logger.debug("No pending ACK/NACK to report")
            return None
        msg = "ACK" if self._last_ack else "NACK"
        # Reset after reading to emulate one-shot acknowledgement
        self._last_ack = None
        self.logger.info("Returning synthetic STM32 ack: %s", msg)
        return msg


    def turn_error_minimization(self, phi: float, offset_known: bool, phi_cur: float, sgn_offset: float = 0):
        if offset_known:

            if (phi + sgn_offset) >= 180:
                phi_opt = -180 + ((phi + sgn_offset) % 180)
            elif (phi + sgn_offset) < -180:
                phi_opt = ((phi + sgn_offset)) % 180
            else:
                phi_opt = (phi + sgn_offset)

            epsl = phi_opt - phi_cur
            if abs(epsl) <= 180:
                return abs(epsl), 1 if epsl > 0 else 0
            else:
                return 360 - epsl, 1 if epsl <= 0 else 0

        else:
            epsl_vars = []
            # basically repeat the above for all k in -2..2
            _CONST_ROT_MAG = 90
            for k in (-2, 3):
                if (phi + _CONST_ROT_MAG * k) >= 180:
                    phi_opt = -180 + ((phi + _CONST_ROT_MAG * k) % 180)
                elif (phi + _CONST_ROT_MAG * k) < -180:
                    phi_opt = (phi + _CONST_ROT_MAG * k) % 180
                else:
                    phi_opt = (phi + _CONST_ROT_MAG * k)

                epsl = phi_opt - phi_cur
                if abs(epsl) <= 180:
                    epsl_vars.append([abs(epsl), 1 if epsl > 0 else 0])
                else:
                    epsl_vars.append([360 - epsl, 1 if epsl <= 0 else 0])
            n = 0
            for k, _ in enumerate(epsl_vars):
                if epsl_vars[k][0] < epsl_vars[n][0]:
                    n = k
            return epsl_vars[n]